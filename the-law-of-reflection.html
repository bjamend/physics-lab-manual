<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Law of Reflection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- External CSS -->
  <link rel="stylesheet" href="manual_entry_style.css" />

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        tags: 'ams',
      },
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>

<body>
  <div class="container">
    <main class="main-box">

      <section
        class="hero"
        style="--hero-bg: url('images/the-law-of-reflection-background.png')"
      >
        <a href="index.html" class="hero__back">← Back to Main Page (PHYS 2240)</a>
        <h1 class="hero__title">The Law of Reflection</h1>
      </section>



      <!-- Navigation Menu -->
      <nav style="margin-top: 2rem;">
        <h2 style="margin-top: 0;">Jump to Section:</h2>
        <ul>
          <li><a href="#background">Historical Background</a></li>
          <li><a href="#theory">Theory</a></li>
          <li><a href="#pre-lab-questions">Pre-Lab Questions</a></li>
          <li><a href="#procedure">Procedure</a></li>
          <li><a href="#virtual-lab-simulation">Virtual Lab Simulation</a></li>
        </ul>
      </nav>

      <!-- Section: Historical Background -->
      <details id="background" open>
        <summary>Historical Background</summary>
        <div>
          <p>
            The law of reflection traces back to ancient Greek geometry, where Euclid<sup><a href="#burton-1945" class="text-blue-300 hover:underline">[1]</a></sup> and later Ptolemy<sup><a href="#smith-1996" class="text-blue-300 hover:underline">[2]</a></sup> described mirror behavior in purely geometric terms.
            Both thinkers supported the "extramission" theory of vision, which held that sight occurs when beams are emitted from the eyes and strike external objects.
            In the early eleventh century, the Arab scholar Ibn al-Haytham conducted the first rigorous experimental studies of reflection in his <em>Book of Optics</em>.
            He demonstrated that light travels in straight lines and reflects predictably from smooth surfaces<sup><a href="#sabra-2023" class="text-blue-300 hover:underline">[3]</a></sup>.
            His experiments also challenged the extramission theory of vision, offering support instead for the intromission theory, which holds that vision occurs when light enters the eyes from external sources<sup><a href="#sabra-1989" class="text-blue-300 hover:underline">[4]</a></sup>.
            During the Renaissance, European thinkers such as Renee Descartes refined these ideas, deriving the law from analytic geometry and linked it to broader mechanistic philosophies of light<sup><a href="#sabra-1981" class="text-blue-300 hover:underline">[5]</a></sup>.
            Pierre de Fermat's principle of least time later offered a variational foundation, showing that the equal-angle rule follows from light's tendency to minimize travel time.
          </p>
          <p>
            In this lab, you will use the law of reflection to measure the radii of curvature of different curved mirrors.
          </p>
        </div>
      </details>

      <!-- Section: Theory -->
      <details id="theory">
        <summary>Theory</summary>
        <div>
          <p>
          <strong>Fermat's Principle</strong> states that light propagates along the path that minimizes its travel time.
          In the absence of interfaces between different mediums, this path trivially corresponds to a straight line.
          As such, the <strong>Law of Rectilinear Propagation</strong> is a natural consequence of Fermat's Principle.
          To obtain the <strong>Law of Reflection</strong>, however, we'll have to put in a bit more work.
        </p>
        <p>
          We begin by characterizing the process of reflection with two rays—an incident and a reflected ray—on an interface between two mediums, as shown in <a href="#fig-1" class="text-blue-300 hover:underline">Figure 1</a> below.
          We want to determine a relationship between the angle of incidence $\theta_i$ and the angle of reflection $\theta_r$ such that the light will take the smallest amount of time to travel from point A to point B.
        </p>
        <figure id="fig-1" class="my-8 text-center">
            <img
              src="figures/lab5/figure1.png"
              alt="Incident and reflected rays"
              class="mx-auto rounded"
            >
            <figcaption class="mt-2 text-sm text-gray-400">
              <strong>Figure 1:</strong> A light ray reflects off an interface between two mediums.
            </figcaption>
          </figure>
          <p>
            The distance traveled by each ray can be calculated via the Pythagorean theorem.
            Using the distances denoted in the figure above, we obtain
          </p>
          <div id="eq-distance">
            <p>
              $$\begin{equation}
                d = \sqrt{h_A^2 + x^2} + \sqrt{h_B^2 + (L - x)^2}\,. \label{eq:distance}
              \end{equation}$$
            </p>
          </div>
          <p>
            To obtain the travel time, we simply divide both sides of <a href="#eq-distance" class="text-blue-300 font-bold hover:underline"> Equation $\ref{eq:distance}$</a> by the speed of light $v$ in the relevant medium.
            The travel time is then given by
          </p>
          <div id="eq-travel-time">
            <p>
              $$\begin{equation}
                t = \frac{\sqrt{h_A^2 + x^2}}{v} + \frac{\sqrt{h_B^2 + (L - x)^2}}{v}\,. \label{eq:travel-time}
              \end{equation}$$
            </p>
          </div>
          <p>
            To minimize this, we differentiate it with respect to $x$—the variable we've used to parameterize the paths—and equate it to zero.
          </p>
          <div id="eq-derivative">
            <p>
              $$\begin{equation}
                \frac{dt}{dx} = \frac{1}{v}\left[ \frac{x}{\sqrt{h_A^2 + x^2}} - \frac{(L-x)}{\sqrt{h_B^2 + (L-x)^2}} \right] \,. \label{eq:derivative}
              \end{equation}$$
            </p>
          </div>
          <p>
            Equating this to zero, we obtain
          </p>
          <div id="eq-path-relation">
            <p>
              $$\begin{equation}
                \frac{x}{\sqrt{h_A^2 + x^2}} = \frac{(L-x)}{\sqrt{h_B^2+(L-x)^2}} \,, \label{eq:path-relation}
              \end{equation}$$
            </p>
          </div>
          <p>
            which is equivalent to
          </p>
          <div id="eq-geometric-relation">
            <p>
              $$\begin{equation}
                \sin{\theta_i} = \sin{\theta_r} \,. \label{eq:geometric-relation}
              \end{equation}$$
            </p>
          </div>
          <p>
            Thus, since the angles are measured relative to the surface normal,
          </p>
          <div id="eq-law-of-reflection">
            <p>
              $$\begin{equation}
                \boxed{\theta_i = \theta_r} \,. \label{eq:law-of-reflection}
              \end{equation}$$
            </p>
          </div>
          <p>
            This is, of course, the Law of Reflection: the angle of incidence equals the angle of reflection.
            But how is this applied in practice?
            In this lab, we'll be studying image formation with concave mirrors, so we'll start there.
          </p>
          <p>
            A concave mirror is a portion of a sphere, and the geometric center of that sphere is called the center of curvature $C$.
            The distance from the mirror's surface to this center is known as the radius of curvature, denoted $R$.
            The focal point lies halfway between the mirror's surface and the center of curvature, so the focal length $f$ is related to the radius by $f=R/2$.
            Both $R$ and $f$ are measured from the mirror along the principal axis, which is the straight line that runs through the mirror’s center and the center of curvature.
            For concave mirrors, we take both the focal length and radius of curvature to be positive, because the focal point lies in front of the mirror—the same side as the incoming light.
          </p>
          <p>
            The convergence of light rays to the focal point $f$ is only approximate; rays farther from the principal axis do not meet exactly at the same point, leading to a phenomenon known as <strong>spherical aberration</strong>.
            This phenomenon is more pronounced when the mirror has a smaller radius of curvature, as can be seen in the interactive widget below.
          </p>

          <div style="margin-top: 1.5rem;">
            <!-- Mirror simulation canvas -->
            <div class="flex-row">
              <canvas id="mirrorCanvas" width="600" height="400"></canvas>
            </div>
            <!-- Radius of curvature slider -->
            <div class="flex-row" style="margin-top: 1.5rem;">
              <div class="slider-box">
                <label for="radiusSlider">Radius of Curvature:</label>
                <input
                  type="range"
                  id="radiusSlider"
                  min="215"
                  max="800"
                  value="215"
                />
                <span id="radiusValue">215</span>
              </div>
            </div>
          </div>
          <script>
            const canvas = document.getElementById('mirrorCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('radiusSlider');
            const radiusValue = document.getElementById('radiusValue');
            let R = parseInt(slider.value, 10);

            function drawSegment(sx, sy, ex, ey) {
              const headLen = 12;
              const arrowScale = 0.6;
              const arrowLen = headLen * arrowScale;
              const arrowCount = 3;
              const segLen = Math.hypot(ex - sx, ey - sy);
              if (segLen < 0.0001) return;
              const ux = (ex - sx) / segLen;
              const uy = (ey - sy) / segLen;
              ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
              for (let i = 1; i <= arrowCount; i++) {
                const t = i / (arrowCount + 1);
                const xa = sx + ux * segLen * t;
                const ya = sy + uy * segLen * t;
                const ang = Math.atan2(uy, ux);
                ctx.beginPath();
                ctx.moveTo(xa, ya);
                ctx.lineTo(xa - arrowLen * Math.cos(ang - Math.PI/6), ya - arrowLen * Math.sin(ang - Math.PI/6));
                ctx.lineTo(xa - arrowLen * Math.cos(ang + Math.PI/6), ya - arrowLen * Math.sin(ang + Math.PI/6));
                ctx.closePath(); ctx.fill();
              }
              const angEnd = Math.atan2(ey - sy, ex - sx);
              ctx.beginPath();
              ctx.moveTo(ex, ey);
              ctx.lineTo(ex - arrowLen * Math.cos(angEnd - Math.PI/6), ey - arrowLen * Math.sin(angEnd - Math.PI/6));
              ctx.lineTo(ex - arrowLen * Math.cos(angEnd + Math.PI/6), ey - arrowLen * Math.sin(angEnd + Math.PI/6));
              ctx.closePath(); ctx.fill();
            }

            function draw() {
              const w = canvas.width, h = canvas.height;
              const rayLength = w * 1.5;
              ctx.clearRect(0, 0, w, h);
              const cx = R + 100;
              const cy = h / 2;
              const theta = R >= h/2 ? Math.asin((h/2) / R) : Math.PI/2;

              // draw mirror arc
              ctx.strokeStyle = 'dodgerblue'; ctx.lineWidth = 2;
              ctx.beginPath(); ctx.arc(cx, cy, R, Math.PI - theta, Math.PI + theta); ctx.stroke();

              // draw principal axis
              ctx.strokeStyle = '#aaa'; ctx.lineWidth = 1;
              ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();

              // draw rays
              ctx.strokeStyle = 'crimson'; ctx.fillStyle = 'crimson'; ctx.lineWidth = 1;
              const offsets = [-180, -120, -60, 0, 60, 120, 180];
              offsets.forEach(offset => {
                const y0 = cy + offset;
                const dy0 = y0 - cy;
                const hit1 = Math.abs(dy0) <= R;
                const xHit1 = hit1 ? cx - Math.sqrt(R*R - dy0*dy0) : 0;
                drawSegment(w, y0, xHit1, y0);
                if (!hit1) return;
                const inc = {x: -1, y: 0};
                const norm1 = {x: (xHit1 - cx)/R, y: (y0 - cy)/R};
                const dot1 = inc.x * norm1.x + inc.y * norm1.y;
                const refl1 = {x: inc.x - 2 * dot1 * norm1.x, y: inc.y - 2 * dot1 * norm1.y};
                const t2 = -2 * ((xHit1 - cx) * refl1.x + (y0 - cy) * refl1.y);
                let didSecond = false;
                if (t2 > 0 && t2 < rayLength) {
                  const xHit2 = xHit1 + refl1.x * t2;
                  const yHit2 = y0 + refl1.y * t2;
                  const onArc = xHit2 <= cx && Math.abs(yHit2 - cy) <= R * Math.sin(theta);
                  if (onArc) {
                    drawSegment(xHit1, y0, xHit2, yHit2);
                    const norm2 = {x: (xHit2 - cx)/R, y: (yHit2 - cy)/R};
                    const dot2 = refl1.x * norm2.x + refl1.y * norm2.y;
                    const refl2 = {x: refl1.x - 2 * dot2 * norm2.x, y: refl1.y - 2 * dot2 * norm2.y};
                    const rem = rayLength - t2;
                    const xEnd = xHit2 + refl2.x * rem;
                    const yEnd = yHit2 + refl2.y * rem;
                    drawSegment(xHit2, yHit2, xEnd, yEnd);
                    didSecond = true;
                  }
                }
                if (!didSecond) {
                  const xEnd1 = xHit1 + refl1.x * rayLength;
                  const yEnd1 = y0 + refl1.y * rayLength;
                  drawSegment(xHit1, y0, xEnd1, yEnd1);
                }
              });

              // draw center of curvature on top
              ctx.fillStyle = 'white';
              ctx.beginPath(); ctx.arc(cx, cy, 5, 0, 2*Math.PI); ctx.fill();
              ctx.fillStyle = 'white'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('C', cx + 6, cy + 4);

              // draw focal point on top
              const f = R/2;
              const fx = cx - f;
              ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(fx, cy, 5, 0, 2*Math.PI); ctx.fill();
              ctx.fillStyle = 'white'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('f', fx + 6, cy + 4);
            }

            slider.addEventListener('input', () => { R = +slider.value; radiusValue.textContent = R; draw(); });
            draw();
          </script>

          <p>
            To understand how a mirror forms an image of an object, we use a graphical method called <strong>ray tracing</strong>.
            The idea is to draw just a few specific light rays coming from the top of the object, which reflect in predictable ways, allowing us to find the location where the reflected rays intersect.
            We will not be accounting for the effects of spherical aberration in this procedure, but it is worth keeping in mind as a source of error, particularly for mirrors with smaller $R$.
          </p>

          <p>
            The interactive widget below illustrates the three principal rays commonly used in ray-tracing diagrams for concave mirrors.
            The first ray travels parallel to the principal axis and reflects through the focal point.
            The second ray strikes the vertex of the mirror (where the mirror meets the principal axis) and reflects symmetrically with respect to the principal axis.
            The third ray passes through the focal point before reaching the mirror and reflects parallel to the principal axis.
          </p>

          <div style="margin-top: 1.5rem;">
            <div class="flex-row">
              <canvas id="diagram" width="600" height="400"></canvas>
            </div>
            <div class="flex-row" style="margin-top: 1.5rem;">
              <div class="slider-box">
                <label for="objectDist">Object Distance:</label>
                <input type="range" id="objectDist" min="150" max="400" value="200" />
                <span id="distVal">200</span>
              </div>
            </div>
          </div>
          <script>
            (function() {
              const diagCanvas = document.getElementById('diagram');
              const diagCtx    = diagCanvas.getContext('2d');
              const centerX    = diagCanvas.width * 0.7;
              const centerY    = diagCanvas.height / 2;
              const focalLen   = 100;
              const mirrorH    = 185;
              const R          = 2 * focalLen;
              const baseH      = mirrorH * 0.457;

              function drawArrow(x1,y1,x2,y2,col,w){
                const headlen = w>2 ? 20*(Math.abs(y2-y1)/baseH) : 8;
                const halfW   = w>2 ? 10 : 4;
                const ang     = Math.atan2(y2-y1,x2-x1);
                const bx      = x2 - headlen * Math.cos(ang);
                const by      = y2 - headlen * Math.sin(ang);
                const sx      = bx + Math.cos(ang);
                const sy      = by + Math.sin(ang);
                diagCtx.strokeStyle = col;
                diagCtx.fillStyle   = col;
                diagCtx.lineWidth   = w;
                diagCtx.beginPath(); diagCtx.moveTo(x1,y1); diagCtx.lineTo(sx,sy); diagCtx.stroke();
                diagCtx.beginPath();
                diagCtx.moveTo(x2,y2);
                diagCtx.lineTo(sx - halfW * Math.sin(ang), sy + halfW * Math.cos(ang));
                diagCtx.lineTo(sx + halfW * Math.sin(ang), sy - halfW * Math.cos(ang));
                diagCtx.closePath(); diagCtx.fill();
              }

              function drawHead(x,y,ang,col,w){
                const headlen = 8;
                diagCtx.fillStyle   = col;
                diagCtx.strokeStyle = col;
                diagCtx.lineWidth   = w;
                diagCtx.beginPath();
                diagCtx.moveTo(x,y);
                diagCtx.lineTo(x - headlen * Math.cos(ang - Math.PI/6), y - headlen * Math.sin(ang - Math.PI/6));
                diagCtx.lineTo(x - headlen * Math.cos(ang + Math.PI/6), y - headlen * Math.sin(ang + Math.PI/6));
                diagCtx.closePath(); diagCtx.fill();
              }

              const slider     = document.getElementById('objectDist');
              const valDisplay = document.getElementById('distVal');
              valDisplay.textContent = slider.value;
              slider.addEventListener('input', () => { valDisplay.textContent = slider.value; drawRays(); });

              function drawRays() {
                diagCtx.clearRect(0,0,diagCanvas.width,diagCanvas.height);
                diagCtx.lineWidth = 1;
                diagCtx.font      = '12px sans-serif';

                // Principal axis
                diagCtx.strokeStyle = '#fff';
                diagCtx.beginPath(); diagCtx.moveTo(0,centerY); diagCtx.lineTo(diagCanvas.width,centerY); diagCtx.stroke();

                // Mirror shape
                const cxArc = centerX - R;
                const phi   = Math.asin(mirrorH / R);
                diagCtx.strokeStyle = 'dodgerblue'; diagCtx.lineWidth = 2;
                diagCtx.beginPath(); diagCtx.arc(cxArc,centerY,R,-phi,phi); diagCtx.stroke();
                diagCtx.beginPath(); diagCtx.moveTo(centerX,centerY-mirrorH); diagCtx.lineTo(centerX,centerY+mirrorH); diagCtx.stroke();
                const arcX = cxArc + R * Math.cos(phi);
                diagCtx.beginPath();
                diagCtx.moveTo(arcX,centerY-mirrorH); diagCtx.lineTo(centerX,centerY-mirrorH);
                diagCtx.moveTo(arcX,centerY+mirrorH); diagCtx.lineTo(centerX,centerY+mirrorH);
                diagCtx.stroke();

                // Compute object
                const d_o  = parseFloat(slider.value);
                const objX = centerX - d_o;
                const objY = centerY - baseH;
                const fx   = centerX - focalLen;
                const dy2  = centerY - objY;
                const dx2  = centerX - objX;

                // Ray segments
                const yHitMirror = objY + dx2 * dy2 / (fx - objX);
                const r1_endY    = objY + dy2 * ((0 - centerX) / (fx - centerX));

                const segments = [
                  // Ray 1
                  [{x:objX,y:objY},{x:centerX,y:objY}],
                  [{x:centerX,y:objY},{x:0,y:r1_endY}],
                  // Ray 2
                  [{x:objX,y:objY},{x:centerX,y:centerY}],
                  [{x:centerX,y:centerY},{x:-50,y:centerY - dy2 * ((-50 - centerX)/dx2)}],
                  // Ray 3
                  [{x:objX,y:objY},{x:centerX,y:yHitMirror}],
                  [{x:centerX,y:yHitMirror},{x:0,y:yHitMirror}]
                ];

                segments.forEach(([p1,p2]) => {
                  const ang = Math.atan2(p2.y-p1.y,p2.x-p1.x);
                  drawArrow(p1.x,p1.y,p2.x,p2.y,'crimson',1.25);
                  const hx = p1.x + (p2.x-p1.x)*0.5;
                  const hy = p1.y + (p2.y-p1.y)*0.5;
                  drawHead(hx,hy,ang,'crimson',1.5);
                });

                // Object arrow
                drawArrow(objX,centerY,objX,objY,'white',5);
                diagCtx.font      = 'bold 14px sans-serif'; diagCtx.fillStyle = 'white';
                diagCtx.fillText('O', objX - 15, objY - 6);

                // Image arrow
                const dx1   = fx - centerX;
                const dy1   = centerY - objY;
                const yImg  = yHitMirror;
                const xImg  = centerX + dx1 * ((yImg - objY)/dy1);
                drawArrow(xImg,centerY,xImg,yImg,'white',5);
                diagCtx.fillText('I', xImg - 15, yImg + 6);

                // C and F
                diagCtx.beginPath(); diagCtx.arc(cxArc,centerY,5,0,2*Math.PI); diagCtx.fill(); diagCtx.fillText('C',cxArc+6,centerY-6);
                diagCtx.beginPath(); diagCtx.arc(fx,centerY,5,0,2*Math.PI); diagCtx.fill(); diagCtx.fillText('f',fx+6,centerY-6);
              }

              drawRays();
            })();
          </script>

          <p>
            Note how the properties of the reflected image change based on whether the object is interior or exterior to $C$ relative to the mirror vertex.
            Additionally, note that the reflected rays are shown as if they reflect off a flat surface positioned at the mirror's vertex, rather than the actual curved surface.
            This simplification avoids spherical aberration in the converging rays, though such aberration will still exist as a source of error in reality.
          </p>

          <p>
            The relationship between the object distance $d_o$, image distance $d_i$, and focal length $f$ is given by the mirror equation,
          </p>

          <div id="eq-mirror-equation">
            <p>
              $$\begin{equation}
                \boxed{\frac{1}{f} = \frac{1}{d_o} + \frac{1}{d_i}} \,. \label{eq:mirror-equation}
              \end{equation}$$
            </p>
          </div>

          <p>
            Note that the distances are relative to the mirror vertex.
          </p>

          <!-- Collapsible Derivation Frame -->
          <details class="derivation-box">
            <summary>
              Derivation 1
            </summary>

            <div>
              <figure id="fig-d1" class="my-8 text-center">
                <img
                  src="figures/lab5/figure2.png"
                  alt="Principal rays"
                  class="mx-auto rounded"
                >
                <figcaption class="mt-2 text-sm text-gray-400">
                  <strong>Figure D1.1:</strong> Two principal rays used to derive the mirror equation.
                </figcaption>
              </figure>

              <p>
                The mirror equation can be derived in a geometrical framework using similar triangles.
                From the figure above,
              </p>

              <div id="eq-tangent-theta">
                <p>
                  $$\tan{\theta} = \frac{h_o}{d_o}\,, \hspace{0.5cm} \tan{\theta'} = \frac{h_i}{d_i}\,, \tag{D1.1}$$
                </p>
              </div>

              <p>
                and
              </p>

              <div id="eq-tangent-phi">
                <p>
                  $$\tan{\phi} = \frac{h_o}{d_o - f}\,, \hspace{0.5cm} \tan{\phi'} = \frac{h_i}{f}\,. \tag{D1.2}$$
                </p>
              </div>

              <p>
                Since $\theta=-\theta'$ and $\phi=-\phi'$,
              </p>

              <div id="eq-tangent-equality">
                <p>
                  $$ \frac{h_o}{d_o} = -\frac{h_i}{d_i}\,, \hspace{0.5cm} \frac{h_o}{d_o - f} = \frac{h_i}{f}\,. \tag{D1.3}$$
                </p>
              </div>

              <p>
                Solving this system of equations, both $h_i$ and $h_o$ are eliminated simultaneously, and we end up with the mirror equation,
              </p>

              <div id="eq-result">
                <p>
                  $$ \boxed{\frac{1}{f} = \frac{1}{d_o} + \frac{1}{d_i}} \,. \tag{D1.4}$$
                </p>
              </div>

            </div>
          </details>

        </div>
      </details>

      <!-- Section: Pre-Lab Questions -->
      <details id="pre-lab-questions">
        <summary>Pre-Lab Questions</summary>
        <div class="box">
          <p>
            Submit your responses to the following questions by the start of the relevant lab meeting.
          </p>
          <ol class="list-decimal">
            <li>
              <p>
                When the object lies between the focal point and the center of curvature ($f < d_o < C$), the concave mirror produces a real image larger than the object.
                By contrast, if the object is placed beyond the center of curvature ($d_o > C$), the real image formed is smaller in height than the object.
                What do you expect will happen to the image if the object is placed within the focal point ($d_o < f$)?
              </p>
            </li>
            <li>
              <p>
                Look up the story on the mirror flaw in the Hubble Space Telescope.
                What went wrong, and how was it fixed?
              </p>
            </li>
            <li>
              <p>
                What are parabolic mirrors, and why might they be preferred over spherical mirrors?
              </p>
            </li>
            <li>
              <p>
                Why might we be opting to work solely with concave mirrors in this lab instead of convex mirrors?
              </p>
            </li>
            <li>
              <p>
                An object is placed $30\,\mathrm{cm}$ from the vertex of a concave mirror, and a corresponding image is produced, located $15\,\mathrm{cm}$ from the vertex.
                What is the mirror's radius of curvature $R$?
              </p>
            </li>
          </ol>
        </div>
      </details>

      <!-- Section: Procedure -->
      <details id="procedure">
        <summary>Procedure</summary>
        <div class="box">
          <p>Determine the radii of curvature of three different spherical mirrors.</p>
        </div>
      </details>

      <!-- Section: Virtual Lab Simulation -->
      <details id="virtual-lab-simulation" class="mb-8">
        <summary class="text-xl font-bold cursor-pointer hover:text-blue-300">
          Virtual Lab Simulation
        </summary>
        <div class="mt-6 space-y-4 text-gray-100">
          <p class="online-only-note">
            <strong>This section is only relevant if you are doing this lab online instead of in-person.</strong>
          </p>
          <p>
            Use the setup in the interactive widget below to determine the focal length (and radius of curvature) of a concave mirror by adjusting object and screen positions.
          </p>
          <div id="optical-bench-widget"
               class="p-4 bg-gray-900 rounded-lg shadow-lg mx-auto"
               style="width:100%; max-width:820px;">
            <!-- canvas now fills the container up to 820px, keeps 3:2 aspect ratio -->
            <canvas id="benchCanvas"
                    class="border border-gray-700 block bg-black"
                    style="width:100%; height:auto; aspect-ratio:3/2;">
            </canvas>

            <div class="flex-row" style="margin-top: 1rem; justify-content: center;">
              <div class="slider-box mx-4">
                <label for="doSlider" class="block text-gray-200">Object Distance ($d_o$):</label>
                <input type="range" id="doSlider" min="0" max="100" value="50" step="0.1" class="w-full">
                <input type="number" id="doInput" min="0" max="100" step="0.1" value="50"
                       class="mt-1 w-20 text-gray-900"/>
                <span class="text-gray-200 ml-1">cm</span>
              </div>
              <div class="slider-box mx-4">
                <label for="dsSlider" class="block text-gray-200">Screen Distance ($d_s$):</label>
                <input type="range" id="dsSlider" min="0" max="100" value="50" step="0.1" class="w-full">
                <input type="number" id="dsInput" min="0" max="100" step="0.1" value="50"
                       class="mt-1 w-20 text-gray-900"/>
                <span class="text-gray-200 ml-1">cm</span>
              </div>
            </div>
          </div>
        </div>
      </details>

      <script>
      (function(){
        const benchCanvas = document.getElementById('benchCanvas');
        const benchCtx    = benchCanvas.getContext('2d');
        const img         = new Image();
        img.src = 'images/candle.png';

        // optical parameters
        const axisCm         = 100;
        const R              = 0.2 * axisCm; // 20 cm
        const f              = R / 2;        // 10 cm
        const objectHeightCm = 10;

        const doSlider = document.getElementById('doSlider');
        const dsSlider = document.getElementById('dsSlider');
        const doInput  = document.getElementById('doInput');
        const dsInput  = document.getElementById('dsInput');

        function syncDo(val) {
          const v = Math.max(0, Math.min(axisCm, parseFloat(val) || 0));
          doSlider.value = v;
          doInput.value  = v.toFixed(1);
          draw();
        }
        function syncDs(val) {
          const v = Math.max(0, Math.min(axisCm, parseFloat(val) || 0));
          dsSlider.value = v;
          dsInput.value  = v.toFixed(1);
          draw();
        }
        doSlider.addEventListener('input', () => syncDo(doSlider.value));
        doInput.addEventListener('change', () => syncDo(doInput.value));
        dsSlider.addEventListener('input', () => syncDs(dsSlider.value));
        dsInput.addEventListener('change', () => syncDs(dsInput.value));

        const baselineY  = () => benchCanvas.height / 2;
        const lineHeight = () => benchCanvas.height * 0.4;

        // resize the internal drawing buffer to match CSS-rendered size
        function resizeCanvas() {
          const rect = benchCanvas.getBoundingClientRect();
          const w = rect.width;
          const h = w * (400 / 600);  // preserve 600×400 → aspect 3:2
          benchCanvas.width  = Math.floor(w);
          benchCanvas.height = Math.floor(h);
        }

        // redraw whenever the window resizes
        window.addEventListener('resize', () => {
          resizeCanvas();
          draw();
        });

        function draw() {
          // on first call, ensure canvas is sized
          if (benchCanvas.width === 0) resizeCanvas();

          const scale   = benchCanvas.width / axisCm; // px per cm
          const d_o     = parseFloat(doSlider.value);
          const d_s     = parseFloat(dsSlider.value);
          const d_i     = 1 / ((1 / f) - (1 / d_o));
          const defocus = Math.abs(d_s - d_i);

          const mirrorPx = benchCanvas.width;
          const xO       = mirrorPx - d_o * scale;
          const xS       = mirrorPx - d_s * scale;

          benchCtx.clearRect(0, 0, benchCanvas.width, benchCanvas.height);

          // principal axis (semi-transparent gray)
          benchCtx.strokeStyle = 'rgba(128,128,128,0.5)';
          benchCtx.lineWidth   = 1;
          benchCtx.beginPath();
          benchCtx.moveTo(0, baselineY());
          benchCtx.lineTo(benchCanvas.width, baselineY());
          benchCtx.stroke();

          // blurred inverted image
          const imageHeightPx = objectHeightCm * (d_i / d_o) * scale;
          benchCtx.save();
          benchCtx.filter    = `blur(${defocus * 1.5}px)`;
          benchCtx.translate(0, baselineY());
          benchCtx.scale(1, -1);
          const imgW = imageHeightPx * (img.width / img.height);
          benchCtx.drawImage(img, xS - imgW/2, -imageHeightPx, imgW, imageHeightPx);
          benchCtx.restore();

          // mirror arc
          const radiusPx     = R * scale;
          const circleCenter = mirrorPx - radiusPx;
          benchCtx.strokeStyle = 'dodgerblue';
          benchCtx.lineWidth   = 2;
          benchCtx.beginPath();
          benchCtx.arc(circleCenter, baselineY(), radiusPx, -Math.PI/3, Math.PI/3);
          benchCtx.stroke();

          // upright object image
          const objHeightPx = objectHeightCm * scale;
          const objW        = objHeightPx * (img.width / img.height);
          benchCtx.drawImage(img, xO - objW/2, baselineY() - objHeightPx, objW, objHeightPx);

          // crosses at object & screen
          const crossSize = 6;
          benchCtx.strokeStyle = '#fff';
          benchCtx.lineWidth   = 2;
          [xS, xO].forEach(x => {
            benchCtx.beginPath();
            benchCtx.moveTo(x - crossSize, baselineY());
            benchCtx.lineTo(x + crossSize, baselineY());
            benchCtx.moveTo(x, baselineY() - crossSize);
            benchCtx.lineTo(x, baselineY() + crossSize);
            benchCtx.stroke();
          });
        }

        // wait for the image to load, then size & draw
        img.onload = () => {
          resizeCanvas();
          draw();
        };
      })();
      </script>

      <!-- Section: Footnotes -->
      <footer>
        <p id="burton-1945">
          [1] Burton, Harry Edwin. "The Optics of Euclid." Journal of the Optical Society of America 35, no. 5 (May 1945): 357–372. doi:10.1364/JOSA.35.000357.
        </p>
        <p id="smith-1996">
          [2] Smith, A. Mark. Ptolemy’s Theory of Visual Perception: An English Translation of the Optics. The American Philosophical Society, 1996. ISBN-10 871698625.
        </p>
        <p id="sabra-2023">
          [3] Ibn al‑Haytham. The Optics of Ibn al‑Haytham: Books IV–V: On Reflection and Images Seen by Reflection. Translated and edited by A. I. Sabra; revised by Jan P. Hogendijk. 2 vol. Warburg Institute Studies & Texts. Chicago: University of Chicago Press (distributed for the Warburg Institute), 2023. ISBN 978‑1908590589.
        </p>
        <p id="sabra-1989">
          [4] Ibn al-Haytham. The Optics of Ibn al-Haytham: Books I–III: On Direct Vision. Translated and edited by A. I. Sabra. London: The Warburg Institute, 1989.
        </p>
        <p id="sabra-1981">
          [5] Sabra, A. I. Theories of Light: From Descartes to Newton. Cambridge University Press, 1981.
        </p>
      </footer>

    </main>
  </div>
</body>
</html>