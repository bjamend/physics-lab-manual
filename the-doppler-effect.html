<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Doppler Effect</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- External CSS -->
  <link rel="stylesheet" href="manual_entry_style.css" />

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        tags: 'ams',
      },
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>

<body>
  <div class="container">
    <main class="main-box">

      <section
        class="hero"
        style="--hero-bg: url('images/doppler-shift-background.png')"
      >
        <a href="index.html" class="hero__back">← Back to Main Page (PHYS 2240)</a>
        <h1 class="hero__title">The Doppler Effect</h1>
      </section>

      <!-- Navigation Menu -->
      <nav style="margin-top: 2rem;">
        <h2 style="margin-top: 0;">Jump to Section:</h2>
        <ul>
          <li><a href="#background">Historical Background</a></li>
          <li><a href="#theory">Theory</a></li>
          <li><a href="#pre-lab-questions">Pre-Lab Questions</a></li>
          <li><a href="#procedure">Procedure</a></li>
          <li><a href="#virtual-lab-simulation">Virtual Lab Simulation</a></li>
        </ul>
      </nav>

      <!-- Section: Historical Background -->
      <details id="background" open>
        <summary>Historical Background</summary>
        <div>
          <p>
            The classical Doppler effect was first described in 1842 by Austrian physicist Christian Doppler, who proposed that the observed frequency of a wave depends on the relative motion between the source and the observer<sup><a href="#eden-1992" class="text-blue-300 hover:underline">[1]</a></sup>.
            Originally intended to explain color differences in binary stars, his idea was soon tested more directly with sound waves.
            In 1845, Dutch scientist Christophorus Henricus Diedericus Buys Ballot confirmed the effect by using a moving train and trumpet players to demonstrate the change in pitch as the source moved toward and away from a stationary observer<sup><a href="#ballot-1845" class="text-blue-300 hover:underline">[2]</a></sup>.
            Over time, the Doppler effect was applied to other types of waves, including water and light, though the classical formulation assumes a medium and does not account for all behaviors of light.
            A more complete treatment of the Doppler effect for electromagnetic waves would later emerge from developments in modern physics, which will be explored in a subsequent lab.
          </p>
          <p>
            In this lab, you will estimate the speed of sound by measuring the Doppler shift in frequency produced by moving sound sources.
          </p>
        </div>
      </details>

      <!-- Section: Theory -->
      <details id="theory">
        <summary>Theory</summary>
        <div>
          <p>
            Consider a source emitting sound wave crests at a steady rate $f_s$ into a medium where waves travel at sound speed $v$.
            By definition, the source's emission period is $T_s = 1/f_s$.
            If this source were at rest, the spacing between the wave crests would be
          </p>
          <div id="eq-wave-spacing">
            <p>
              $$\begin{equation}
                \Delta \lambda = vT_s\,. \label{eq:wave-spacing}
              \end{equation}$$
            </p>
          </div>
          <p>
            Now suppose the source moves at speed $v_s$ relative to the stationary medium.
            The quantity $v_s$ can be positive or negative depending on the direction of motion.
            In the time $T_s$ between two successive 'emissions', it advances a distance $v_sT_s$, so the spacing of crests observed by a stationary observer becomes
          </p>
          <div id="eq-wave-spacing-2">
            <p>
              $$\begin{equation}
                \Delta \lambda' = \Delta\lambda - v_sT_s = (v-v_s)T_s = \frac{v-v_s}{f_s}\,. \label{eq:wave-spacing-2}
              \end{equation}$$
            </p>
          </div>
          <p>
            Note that if $v_s$ is <em>positive</em>, the spacing between wave crests <em>decreases</em>, and if $v_s$ is <em>negative</em>, this spacing <em>increases</em>.
          </p>
          <p>
            Now consider an observer who moves through the medium at speed $v_o$.
            As was the case with the source speed $v_s$, $v_o$ can be positive (indicating motion <em>towards</em> the source) or negative (indicating motion <em>away</em> from the source).
            From the observer's point of view, the speed of the crests is simply the sum of the wave speed in the medium $v$ with the observer's speed $v_o$.
            The observed frequency $f_o$ is the rate at which the crests pass by,
          </p>
          <div id="eq-observed-frequency">
            <p>
              $$\begin{equation}
                f_o = \frac{v + v_o}{\Delta \lambda'}\,. \label{eq:observed-frequency}
              \end{equation}$$
            </p>
          </div>
          <p>
            Substituting in <a href="#eq-wave-spacing-2" class="text-blue-300 font-bold hover:underline"> Equation $\ref{eq:wave-spacing-2}$</a>, we obtain the general formulation for the Doppler shift—the shift in frequency associated with motion of the source and/or the observer relative to some stationary medium:
          </p>
          <div id="eq-doppler-shift">
            <p>
              $$\begin{equation}
                \boxed{f_o = f_s \frac{v+v_o}{v-v_s}}\,. \label{eq:doppler-shift}
              \end{equation}$$
            </p>
          </div>
        </div>
      </details>

      <!-- Section: Pre-Lab Questions -->
      <details id="pre-lab-questions">
        <summary>Pre-Lab Questions</summary>
        <div class="box">
          <p>
            Submit your responses to the following questions by the start of the relevant lab meeting.
          </p>
          <ol class="list-decimal">
            <li><p>What is the fractional shift in frequency ($f_o/f_s$) heard by a stationary observer from a source moving away at $1/10^{\mathrm{th}}$ the speed of sound?</p></li>
            <li><p>What is the fractional shift in frequency heard by an observer moving at $1/10^{\mathrm{th}}$ the speed of sound away from a stationary source?</p></li>
            <li><p>Compare your answers from questions 1 and 2.
            Are they the same, or different?
            If they are different, explain why.</p></li>
            <li><p>Consider a small speaker attached to a string spinning in a circle of radius $R$ at a rotational frequency $\omega$.
            The speaker emits a tone at frequency $f_s$.
            The plane of rotation is horizontally oriented (think of spinning pizza dough).
            You are standing a distance $d \gg R$ away from the center of rotation, with your ears at the same height as the speaker.
            Taking the sound speed in air to be $v$, write an expression for the frequency you will hear, to within a phase constant.
            Your answer should be a function of $t$, and in terms of $R$, $\omega$, $f_s$, and $v$.
            <strong>Hint:</strong> $d$ should not be included in this expression given the limit that $d \gg R$.</p></li>
            <li><p>Why does the expression you obtained in question 4 break down when you get close to the spinning speaker?</p></li>
          </ol>
        </div>
      </details>

      <!-- Section: Procedure -->
      <details id="procedure">
        <summary>Procedure</summary>
        <div class="box">
          <p>
          Your goal in this lab is to obtain as accurate a measure of the speed of sound as possible.
          An audio analysis tool of some sort will be required in order to accomplish this, and Audacity is recommended since it is free and easy to use. There are two particular features you may find useful upon loading in (or recording) an audio track:
          </p>
          <ol class="list-decimal">
            <li>
              <strong>The Spectrogram View</strong> - This is an alternate view of the sound signal on any given track, showing a color map of the intensities of different frequencies.
              This view can be useful as you can, in some cases, pick out by eye where certain frequency shifts are occurring.
              This view can be enabled by clicking on the three little dots next to the track name and selecting 'Spectrogram'.
            </li>
            <li>
              <strong>The Plot Spectrum Tool</strong> - This generates a histogram of all frequencies over the selected window of time.
              This can be useful for averaging out noisy frequencies, as well as providing a more quantitative measure of what is shown in the spectrogram view.
              This is an analysis tool that can be applied to the entire track or a section of a track; once a selection has been made, it can be found under Analyze -> Plot Spectrum.
              Note that you can also export this histogram data to do further analysis in Python if needed.
            </li>
          </ol>
          <p></p>
          <p>To generate the audio that you will be analyzed, you are encourage to try a few different techniques, including moving sources, moving observers, rotating objects (e.g. pre-lab questions 4 and 5), etc.</p>
        </div>
      </details>

      <details id="virtual-lab-simulation" class="mb-8">
        <summary class="text-xl font-bold cursor-pointer hover:text-blue-300">
          Virtual Lab Simulation
        </summary>
        <div class="mt-6 space-y-4 text-gray-100">
          <p class="online-only-note">
            <strong>This section is only relevant if you are doing this lab online instead of in-person.</strong>
          </p>
          <p>
            The simulation below allows you to set the positions (in m) and velocities (in m/s) of an observer (blue, bottom) and a source (red, top).
            You can also set the emitted frequency of the source in Hz, as well as the simulation end time in seconds.
            Set up a configuration where you can measure the speed of sound using the tips provided in the procedure above, and compare to a value of $343\,\textrm{m/s}$ for error analysis purposes.
          </p>
          <div id="simulation" class="p-4 bg-gray-900 rounded-lg shadow-lg mx-auto" style="max-width:920px;">
            <div class="flex-row" style="margin-top: 1rem; justify-content: center;">
              <div id="timeDisplay">Time: <span id="timeCounter">0.00</span> s</div>
            </div>
            <canvas
              id="simCanvas"
              width="900"
              height="60"
              class="border border-gray-700 block mx-auto bg-black"
            ></canvas>

            <!-- Two-column controls -->
            <div class="flex-row" style="margin-top: 1rem; justify-content: center; gap: 2rem;">
              <!-- Left column -->
              <div class="flex flex-col space-y-4">
                <div class="slider-box">
                  <label for="obsPosX">$x_o$ (m):</label>
                  <input type="number" id="obsPosX" value="0" step="0.1" class="ml-2">
                </div>
                <div class="slider-box">
                  <label for="obsVelX">$v_o$ (m/s):</label>
                  <input type="number" id="obsVelX" value="0" step="0.1" class="ml-2">
                </div>
                <div class="slider-box">
                  <label for="duration">$t_{\mathrm{max}}$ (s):</label>
                  <input type="number" id="duration" value="5" step="0.1" class="ml-2">
                </div>
              </div>

              <!-- Right column -->
              <div class="flex flex-col space-y-4">
                <div class="slider-box">
                  <label for="srcPosX">$x_s$ (m):</label>
                  <input type="number" id="srcPosX" value="-2" step="0.1" class="ml-2">
                </div>
                <div class="slider-box">
                  <label for="srcVelX">$v_s$ (m/s):</label>
                  <input type="number" id="srcVelX" value="1" step="0.1" class="ml-2">
                </div>
                <div class="slider-box">
                  <label for="srcFreq">$f_s$ (Hz):</label>
                  <input type="number" id="srcFreq" value="440" step="1" class="ml-2">
                </div>
              </div>
            </div>

            <div class="flex-row" style="margin-top: 1.5rem; justify-content: center; gap: 1rem;">
              <button id="playPauseBtn" class="button" disabled>Play</button>
              <button id="resetBtn" class="button" disabled>Reset</button>
              <button id="downloadBtn" class="button" disabled>Download WAV</button>
            </div>
          </div>
        </div>
      </details>

      <script>
        const c = 343, dt = 0.01;
        // 20 m wide, 1 m tall window centered on origin
        const world = { xMin: -10, xMax: 10, yMin: -0.5, yMax: 0.5 };
        const ext   = { xMin: -10.5, xMax: 10.5, yMin: -1.0, yMax: 1.0 };
        const yObs = -0.25, ySrc = 0.25; // fixed y positions

        const canvas = document.getElementById('simCanvas'), ctx = canvas.getContext('2d');
        const playBtn = document.getElementById('playPauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const timeSpan = document.getElementById('timeCounter');

        let audioCtx, osc;
        let obsX0, obsVx, srcX0, srcVx, fSrc, duration;
        let startTime = 0, pausedAt = 0, animReq;
        let isStarted = false, isPaused = false;

        function readInputs() {
          obsX0  = parseFloat(document.getElementById('obsPosX').value);
          obsVx  = parseFloat(document.getElementById('obsVelX').value);
          srcX0  = parseFloat(document.getElementById('srcPosX').value);
          srcVx  = parseFloat(document.getElementById('srcVelX').value);
          fSrc   = parseFloat(document.getElementById('srcFreq').value);
          duration = parseFloat(document.getElementById('duration').value);
        }

        function within(bounds, x, y) {
          return x >= bounds.xMin && x <= bounds.xMax && y >= bounds.yMin && y <= bounds.yMax;
        }

        function updateButtons() {
          readInputs();
          const okObs = obsX0 >= world.xMin && obsX0 <= world.xMax;
          const okSrc = srcX0 >= world.xMin && srcX0 <= world.xMax;
          const ok = okObs && okSrc;
          playBtn.disabled = !ok;
          downloadBtn.disabled = !ok;
        }

        function drawStatic() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
          ctx.strokeRect(0, 0, canvas.width, canvas.height);
          readInputs(); timeSpan.textContent = '0.00';
          drawPoint(obsX0, yObs, 'dodgerblue'); drawArrow(obsX0, obsVx, 'dodgerblue');
          drawPoint(srcX0, ySrc, 'crimson'); drawArrow(srcX0, srcVx, 'red');
          updateButtons();
        }

        function drawPoint(x, y, color) {
          const cx = (x - world.xMin) / (world.xMax - world.xMin) * canvas.width;
          const cy = canvas.height - ((y - world.yMin) / (world.yMax - world.yMin) * canvas.height);
          ctx.fillStyle = color;
          ctx.beginPath(); ctx.arc(cx, cy, 5, 0, 2*Math.PI); ctx.fill();
        }

        function drawArrow(x, vx, color) {
          const y = (color === 'dodgerblue' ? yObs : ySrc);
          const length = vx * 0.2;
          const x2 = x + length;
          const cx1 = (x - world.xMin) / (world.xMax - world.xMin) * canvas.width;
          const cx2 = (x2 - world.xMin) / (world.xMax - world.xMin) * canvas.width;
          const cy1 = canvas.height - ((y - world.yMin) / (world.yMax - world.yMin) * canvas.height);
          const head = 6;
          ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(cx1, cy1); ctx.lineTo(cx2, cy1); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx2, cy1);
            ctx.lineTo(cx2 - head, cy1 - head/2);
            ctx.lineTo(cx2 - head, cy1 + head/2);
          ctx.closePath(); ctx.fill();
        }

        function drawFrame() {
          const t = audioCtx.currentTime - startTime;
          if (t <= duration) {
            const ox = obsX0 + obsVx * t;
            const sx = srcX0 + srcVx * t;
            const dx = ox - sx;
            const dy = yObs - ySrc;
            const dist = Math.hypot(dx, dy);
            const ux = dx / dist;
            if (!within(ext, ox, yObs) || !within(ext, sx, ySrc)) {
              osc.stop(); audioCtx.close(); isStarted = false; isPaused = false; playBtn.textContent = 'Play'; return;
            }
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.strokeStyle='#888';ctx.lineWidth=1;ctx.strokeRect(0,0,canvas.width,canvas.height);
            drawPoint(ox, yObs, 'dodgerblue'); drawArrow(ox, obsVx, 'dodgerblue');
            drawPoint(sx, ySrc, 'crimson'); drawArrow(sx, srcVx, 'crimson');
            timeSpan.textContent = t.toFixed(2);
            animReq = requestAnimationFrame(drawFrame);
          } else {
            isStarted = false; isPaused = false; playBtn.textContent = 'Play';
          }
        }

        function scheduleAudioOffline(cb) {
          readInputs(); let endT = duration;
          for (let t = 0; t <= duration; t += dt) {
            const ox = obsX0 + obsVx*t;
            const sx = srcX0 + srcVx*t;
            if (!within(ext, ox, yObs) || !within(ext, sx, ySrc)) { endT = t; break; }
          }
          const sr = 44100, length = Math.ceil(endT*sr);
          const offCtx = new OfflineAudioContext(1, length, sr);
          const oscillator = offCtx.createOscillator(); oscillator.type = 'sine';
          const gain = offCtx.createGain(); gain.gain.value = 0.1;
          oscillator.connect(gain).connect(offCtx.destination);
          for (let t = 0; t <= endT; t += dt) {
            const ox = obsX0 + obsVx*t;
            const sx = srcX0 + srcVx*t;
            const dx = ox - sx, dy = yObs - ySrc;
            const dist = Math.hypot(dx, dy);
            const ux = dx / dist;
            const v_src = srcVx * ux;
            const v_obs = -obsVx * ux;
            const fObs = fSrc * (c + v_obs) / (c - v_src);
            oscillator.frequency.setValueAtTime(fObs, t);
          }
          oscillator.start(0); oscillator.stop(endT);
          offCtx.startRendering().then(buf => {
            const wav = bufferToWave(buf, buf.length);
            const blob = new Blob([wav], { type: 'audio/wav' });
            cb(URL.createObjectURL(blob));
          });
        }

        function bufferToWave(ab, len) {
          const chs = ab.numberOfChannels, size = len*chs*2+44;
          const buffer = new ArrayBuffer(size), view = new DataView(buffer);
          function w(s,o){for(let i=0;i<s.length;i++)view.setUint8(o+i,s.charCodeAt(i));}
          w('RIFF',0); view.setUint32(4,size-8,true);
          w('WAVE',8); w('fmt ',12); view.setUint32(16,16,true);
          view.setUint16(20,1,true); view.setUint16(22,chs,true);
          view.setUint32(24,ab.sampleRate,true);
          view.setUint32(28,ab.sampleRate*chs*2,true);
          view.setUint16(32,chs*2,true); view.setUint16(34,16,true);
          w('data',36); view.setUint32(40,size-44,true);
          let offset=44; const cd=[];
          for(let c=0;c<chs;c++) cd.push(ab.getChannelData(c));
          for(let i=0;i<len;i++){ let s=cd[0][i]; view.setInt16(offset, s<0?s*0x8000:s*0x7FFF, true); offset+=2; }
          return view;
        }

        playBtn.addEventListener('click', ()=>{
          if(!isStarted){
            readInputs();
            audioCtx = new (window.AudioContext||window.webkitAudioContext)();
            osc = audioCtx.createOscillator(); osc.type='sine';
            const gain = audioCtx.createGain(); gain.gain.value=0.1;
            osc.connect(gain).connect(audioCtx.destination);
            startTime = audioCtx.currentTime;
            for(let t=0;t<=duration;t+=dt){
              const ox=obsX0+obsVx*t, sx=srcX0+srcVx*t;
              const dx=ox-sx, dy=yObs-ySrc;
              const dist=Math.hypot(dx,dy);
              const ux=dx/dist;
              const v_src=srcVx*ux;
              const v_obs=-obsVx*ux;
              const fObs=fSrc*(c+v_obs)/(c-v_src);
              osc.frequency.setValueAtTime(fObs, startTime+t);
            }
            osc.start(startTime); osc.stop(startTime+duration+dt);
            isStarted=true; isPaused=false;
            drawFrame(); playBtn.textContent='Pause'; resetBtn.disabled=false;
          } else if(!isPaused){
            audioCtx.suspend().then(()=>{ pausedAt=audioCtx.currentTime-startTime; cancelAnimationFrame(animReq); isPaused=true; playBtn.textContent='Play'; });
          } else {
            audioCtx.resume().then(()=>{ startTime=audioCtx.currentTime-pausedAt; isPaused=false; drawFrame(); playBtn.textContent='Pause'; });
          }
        });

        downloadBtn.addEventListener('click', ()=>{
          scheduleAudioOffline(url=>{ const a=document.createElement('a'); a.href=url; a.download='doppler.wav'; document.body.appendChild(a); a.click(); document.body.removeChild(a); });
        });

        resetBtn.addEventListener('click', ()=>{
          if(isStarted||isPaused){ osc.stop(); audioCtx.close(); }
          cancelAnimationFrame(animReq);
          isStarted=false; isPaused=false; pausedAt=0;
          playBtn.textContent='Play'; resetBtn.disabled=true;
          drawStatic();
        });

        drawStatic(); document.querySelectorAll('input').forEach(i=>i.addEventListener('input', drawStatic));
      </script>

      <!-- Section: Footnotes -->
      <footer>
        <p id="eden-1992">
          [1] Doppler, Christian. On the Coloured Light of the Double Stars and Certain Other Stars of the Heavens. In: Alec Eden, Christian Doppler: Life and Work, translated by Alec Eden and Peter Eden, facsimile edition with English translation. Springer-Verlag, 1992, pp. 99–115.
        </p>
        <p id="ballot-1845">
          [2] C. H. D. Buys Ballot, "Akustische Versuche auf der Niederländischen Eisenbahn, nebst gelegentlichen Bemerkungen zur Theorie des Hrn. Prof. Doppler," Ann. Phys. Chem. 66, 321–351 (1845).
        </p>
      </footer>

    </main>
  </div>
</body>
</html>